<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="浅析Redis本文主要是自己的思考以及《Redis设计与实现》的读书笔记！">
<meta property="og:type" content="article">
<meta property="og:title" content="redis读书笔记">
<meta property="og:url" content="http://yoursite.com/2020/03/01/redis%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="George">
<meta property="og:description" content="浅析Redis本文主要是自己的思考以及《Redis设计与实现》的读书笔记！">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://images0.cnblogs.com/blog2015/754165/201508/111612480989940.png">
<meta property="og:image" content="http://redisbook.com/_images/graphviz-76550f578052d5f52e35414facb5ac680d38c7f5.png">
<meta property="og:image" content="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200112105535.png">
<meta property="og:image" content="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200112105711.png">
<meta property="og:image" content="https://xiaoyue26.github.io/images/2019-03/ask_query.png">
<meta property="article:published_time" content="2020-03-01T01:24:44.000Z">
<meta property="article:modified_time" content="2020-06-24T15:13:08.724Z">
<meta property="article:author" content="George">
<meta property="article:tag" content="读书笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images0.cnblogs.com/blog2015/754165/201508/111612480989940.png">

<link rel="canonical" href="http://yoursite.com/2020/03/01/redis%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>redis读书笔记 | George</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">George</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">专注于思考的programmer</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/importcpp" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/01/redis%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="George">
      <meta itemprop="description" content="It's gonna to be really fun!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="George">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          redis读书笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-01 09:24:44" itemprop="dateCreated datePublished" datetime="2020-03-01T09:24:44+08:00">2020-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-24 23:13:08" itemprop="dateModified" datetime="2020-06-24T23:13:08+08:00">2020-06-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="浅析Redis"><a href="#浅析Redis" class="headerlink" title="浅析Redis"></a>浅析Redis</h1><p>本文主要是自己的思考以及《Redis设计与实现》的读书笔记！</p>
<a id="more"></a>

<h2 id="What-is-Redis"><a href="#What-is-Redis" class="headerlink" title="What is Redis?"></a>What is Redis?</h2><p>Redis -&gt; remote dictionary server，本质是一个Key-Value类型的内存数据库，可以用作数据库、缓存、消息中间件等</p>
<p>整个数据库统统加载在内存当中进行，定期通过异步操作把数据库数据保存在磁盘里面。因为是纯内存操作，使得Redis的性能非常出色</p>
<h3 id="Redis的特点"><a href="#Redis的特点" class="headerlink" title="Redis的特点"></a>Redis的特点</h3><p>Redis作为一个内存数据库，有如下特点</p>
<ul>
<li>丰富的数据类型</li>
<li>支持数据持久化 （RDB和AOF）</li>
<li>复制、哨兵模式和集群</li>
</ul>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul>
<li>读写全部在内存中，速度快</li>
<li>支持多种数据结构</li>
<li>单线程，不用担心竞争</li>
<li>特性丰富，支持持久化、复制、sentinel、集群等</li>
<li>支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行</li>
</ul>
<p>相比于其它数据库，</p>
<h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ul>
<li>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上</li>
<li>Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复</li>
<li>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性</li>
<li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费</li>
</ul>
<h3 id="Redis为什么这么快"><a href="#Redis为什么这么快" class="headerlink" title="Redis为什么这么快"></a>Redis为什么这么快</h3><ul>
<li>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗</li>
<li>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速</li>
<li>数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的</li>
<li>使用多路 I/O 复用模型，非阻塞 IO</li>
<li>todo使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求</li>
</ul>
<h3 id="Redis高可用-3"><a href="#Redis高可用-3" class="headerlink" title="Redis高可用[3]"></a>Redis高可用<a href="https://juejin.im/post/5b7d226a6fb9a01a1e01ff64" target="_blank" rel="noopener">[3]</a></h3><p>在 <code>Redis</code> 中，实现 <strong>高可用</strong> 的技术主要包括 <strong>持久化</strong>、<strong>复制</strong>、<strong>哨兵</strong> 和 <strong>集群</strong>，下面简单说明它们的作用，以及解决了什么样的问题：</p>
<ul>
<li><strong>持久化</strong>：持久化是 <strong>最简单的</strong> 高可用方法。它的主要作用是 <strong>数据备份</strong>，即将数据存储在 <strong>硬盘</strong>，保证数据不会因进程退出而丢失。</li>
<li><strong>复制</strong>：复制是高可用 <code>Redis</code> 的基础，<strong>哨兵</strong> 和 <strong>集群</strong> 都是在 <strong>复制基础</strong> 上实现高可用的。复制主要实现了数据的多机备份以及对于读操作的负载均衡和简单的故障恢复。缺陷是故障恢复无法自动化、写操作无法负载均衡、存储能力受到单机的限制。</li>
<li><strong>哨兵</strong>：在复制的基础上，哨兵实现了 <strong>自动化</strong> 的 <strong>故障恢复</strong>。缺陷是 <strong>写操作</strong> 无法 <strong>负载均衡</strong>，<strong>存储能力</strong> 受到 <strong>单机</strong> 的限制。</li>
<li><strong>集群</strong>：通过集群，<code>Redis</code> 解决了 <strong>写操作</strong> 无法 <strong>负载均衡</strong> 以及 <strong>存储能力</strong> 受到 <strong>单机限制</strong> 的问题，实现了较为 <strong>完善</strong> 的 <strong>高可用方案</strong>。</li>
</ul>
<h2 id="数据结构与对象"><a href="#数据结构与对象" class="headerlink" title="数据结构与对象"></a>数据结构与对象</h2><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ul>
<li>Redis 服务器是一个事件驱动程序， 服务器处理的事件分为时间事件和文件事件两类。</li>
<li>文件事件处理器是基于 Reactor 模式实现的网络通讯程序。</li>
<li>文件事件是对套接字操作的抽象： 每次套接字变得可应答（acceptable）、可写（writable）或者可读（readable）时， 相应的文件事件就会产生。</li>
<li>文件事件分为 <code>AE_READABLE</code> 事件（读事件）和 <code>AE_WRITABLE</code> 事件（写事件）两类。</li>
<li>时间事件分为定时事件和周期性事件： 定时事件只在指定的时间达到一次， 而周期性事件则每隔一段时间到达一次。</li>
<li>服务器在一般情况下只执行 <code>serverCron</code> 函数一个时间事件， 并且这个事件是周期性事件。</li>
<li>文件事件和时间事件之间是合作关系， 服务器会轮流处理这两种事件， 并且处理事件的过程中也不会进行抢占。</li>
<li>时间事件的实际处理时间通常会比设定的到达时间晚一些</li>
</ul>
<h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><h4 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h4><p>redis 过期策略是：定期删除+惰性删除</p>
<ul>
<li><p>定期删除</p>
<p>每隔一段时间主动查找并删除过期键</p>
<p>redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除</p>
</li>
<li><p>惰性删除</p>
<p>只在碰到过期键时才进行删除操作</p>
<p>在你获取某个 key 的时候，redis 会检查一下 ，这个 key 如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西</p>
</li>
</ul>
<p>Redis摒弃了定时删除</p>
<h3 id="缓存淘汰策略"><a href="#缓存淘汰策略" class="headerlink" title="缓存淘汰策略"></a>缓存淘汰策略</h3><ul>
<li>noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了</li>
<li>allkeys-lru：当内存不足以容纳新写入数据时，<strong>在键空间中</strong>，移除最近最少使用的 key<strong>（这个是最常用的）</strong> LRU</li>
<li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的 key 给干掉啊</li>
<li>volatile-lru：当内存不足以容纳新写入数据时，在<strong>设置了过期时间的键空间中</strong>，移除最近最少使用的 key<strong>（这个一般不太合适）</strong></li>
<li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key</li>
<li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除</li>
</ul>
<h2 id="持久化方案及基本原理"><a href="#持久化方案及基本原理" class="headerlink" title="持久化方案及基本原理"></a>持久化方案及基本原理</h2><p><strong>Redis为了保证效率，将数据缓存在了内存中，但是会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件中，以保证数据的持久化。</strong>如果不把储存在内存中的数据库状态保存到磁盘里面，那么一旦服务器进程退出，服务器中的数据库状态也会消失不见</p>
<p><strong>Redis的持久化策略</strong></p>
<ul>
<li>RBD:  (RDB is for Redis Database Backup file) 通过快照直接把内存中的数据保存到一个dump文件中，所以即使Redis服务器进程退出，但只要RDB文件存在，Redis服务器就可以用它来还原数据库状态</li>
<li></li>
</ul>
<h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>默认Redis是会以快照“RDB”的形式将数据持久化到磁盘的一个二进制文件dump.rdb.  <strong>RDB持久化是通过保存数据库中的键值对来记录数据库状态的</strong></p>
<h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><p>RDB生成有两种办法SAVE和BGSAVE</p>
<ul>
<li>SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求</li>
<li>BGSAVE命令会fork出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求</li>
</ul>
<p>Note：<strong>Redis在进行数据持久化的过程中，会先将数据写入到一个临时文件中，待持久化过程都结束了，才会用这个临时文件替换上次持久化好的文件</strong>。正是这种特性，让我们可以随时来进行备份，因为快照文件总是完整可用的。</p>
<p>在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中，因此，数据库中包含过期键不会对生成新的RDB文件造成影响</p>
<h5 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h5><p><strong>优点</strong></p>
<ul>
<li>通过创建一个子进程的方法将Redis 的内存数据保存到硬盘中，因此，它并不会对 Redis 服务器性能造成多大的影响</li>
<li>非常适用于定时备份和定期备份，服务器遇到问题时可以将数据集还原到不同的版本</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><a href="https://blog.csdn.net/lihao21/article/details/74859707" target="_blank" rel="noopener">[Ref]</a> 尽管快照持久化允许 Redis 恢复到快照文件的状态，但如果 RDB 文件生成后，Redis 服务器继续处理了写命令导致 Redis 内存数据有更新，这时恰好 Redis 崩溃了而来不及保存新的 RDB 文件，那么 Redis 将会丢失这部分新的数据。也就是说，如果系统真的发生崩溃，那么我们将会丢失最近一次生成 RDB 文件之后更改的所有数据。因此，<strong>快照持久化方法只适用于那些即使丢失一部分数据也不会造成问题的应用场景</strong>。</li>
<li>快照持久化方法需要调用<code>fork()</code>方法创建子进程。当 Redis 内存的数据量较大时，创建子进程和生成 RDB 文件得占用较多的系统资源和处理时间，这会对 Redis 正常处理客户端命令的性能造成较大的影响。</li>
</ul>
<h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><h5 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h5><p>与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，<strong>AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的</strong></p>
<p><strong>AOF持久化功能的实现可以分为命令追加、文件写入和文件同步三个步骤</strong></p>
<h6 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h6><p>当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会议协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾</p>
<h6 id="文件写入与同步"><a href="#文件写入与同步" class="headerlink" title="文件写入与同步"></a>文件写入与同步</h6><p>因为服务器在处理文件事件时可能会执行写命令， 使得一些内容被追加到 <code>aof_buf</code> 缓冲区里面， 所以在服务器每次结束一个事件循环之前， 它都会调用 <code>flushAppendOnlyFile</code> 函数， 考虑是否需要将 <code>aof_buf</code> 缓冲区中的内容写入和保存到 AOF 文件里面</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eventLoop</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 处理文件事件，接收命令请求以及发送命令回复</span></span><br><span class="line">        <span class="comment"># 处理命令请求时可能会有新内容被追加到 aof_buf 缓冲区中</span></span><br><span class="line">        processFileEvents()</span><br><span class="line">        <span class="comment"># 处理时间事件</span></span><br><span class="line">        processTimeEvents()</span><br><span class="line">        <span class="comment"># 考虑是否要将 aof_buf 中的内容写入和保存到 AOF 文件里面</span></span><br><span class="line">        flushAppendOnlyFile()</span><br></pre></td></tr></table></figure>

<p><code>flushAppendOnlyFile</code> 函数的行为由服务器配置的 <code>appendfsync</code> 选项的值来决定， 如果用户没有主动为 <code>appendfsync</code> 选项设置值， 那么 <code>appendfsync</code> 选项的默认值为 <code>everysec</code>(将 <code>aof_buf</code> 缓冲区中的所有内容写入到 AOF 文件， <strong>如果上次同步 AOF 文件的时间距离现在超过一秒钟， 那么再次对 AOF 文件进行同步， 并且这个同步操作是由一个线程专门负责执行的</strong>)</p>
<blockquote>
<p>文件的写入和同步</p>
<p>为了提高文件的写入效率， 在现代操作系统中， 当用户调用 <code>write</code> 函数， 将一些数据写入到文件的时候， 操作系统通常会将写入数据暂时保存在一个内存缓冲区里面， 等到缓冲区的空间被填满、或者超过了指定的时限之后， 才真正地将缓冲区中的数据写入到磁盘里面。</p>
<p>这种做法虽然提高了效率， 但也为写入数据带来了安全问题， 因为如果计算机发生停机， 那么保存在内存缓冲区里面的写入数据将会丢失。</p>
<p>为此， 系统提供了 <code>fsync</code> 和 <code>fdatasync</code> 两个同步函数， 它们可以强制让操作系统立即将缓冲区中的数据写入到硬盘里面， 从而确保写入数据的安全性。</p>
</blockquote>
<h6 id="AOF文件重写"><a href="#AOF文件重写" class="headerlink" title="AOF文件重写"></a>AOF文件重写</h6><p>Redis提供AOF文件重写功能主要是为了解决AOF文件体积膨胀的问题，通过该功能，Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个AOF文件所保存的数据库状态相同，但新AOF文件不会包含任何浪费空间的冗余命令，所以新AOF文件的体积通常会比旧AOF文件的体积小很多。</p>
<p><strong>AOF重写实现原理</strong>：<strong>首先从数据库中读取键现在的指，然后用一条命令去记录键值对代替之前的记录之键值对的多条命令</strong>，新AOF文件不会包含任何浪费空间的冗余命令，所以新AOF文件的体积通常会比旧AOF文件的体积小很多。重写程序在处理列表、哈希表、集合和有序集合则四种可能会带有多个元素的键时，会检查键所包含的元素的个数，如果元素的数量超过了设定常量的值，那么重写程序会使用多条命令来记录键的值，而不是单使用一条命令</p>
<h6 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h6><p>因为Redis使用单个线程处理请求，为防止服务器进程阻塞（服务器无法处理客户端发来的命令请求），所以Redis将AOF重写放到子进程执行，这样由两个好处</p>
<ol>
<li>子进程执行AOF重写期间，服务器进程（父进程）可以继续处理命令请求</li>
<li><strong>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以避免使用锁的情况下，保证数据的安全性</strong></li>
</ol>
<p><strong>基本思路</strong></p>
<ul>
<li>重写会有大量的写入操作，所以服务器进程会<code>fork</code>一个子进程来创建一个新的AOF文件</li>
<li>在重写期间，服务器进程继续处理命令请求，如果有写入的命令，会造成重写后的AOF文件和服务器当前的数据库状态不一致的问题，为了解决这种数据不一致的问题，Redis服务器设置了一个AOF重写缓冲区，在有新的吸入命令到达时，追加到<code>aof_buf</code>的同时，还会追加到<code>aof_rewrite_buf</code>AOF重写缓冲区。当子进程完成重写之后，会给父进程一个信号，然后父进程会把AOF重写缓冲区的内容写进新的AOF临时文件中，再对新的AOF文件改名完成替换，这样可以保证新的AOF文件与当前数据库数据的一致性。</li>
</ul>
<p><strong>以下是后台重写 AOF 文件（BGREWRITEAOF）的工作步骤：</strong></p>
<p>1) 用户调用 BGREWRITEAOF</p>
<p>2) Redis 调用这个函数，它执行 fork() ：<br>    2a)子进程在临时文件中对 AOF 文件进行重写<br>    2b)父进程将新输入的写命令追加到 server.aof_rewrite_buf 中</p>
<p>3) 当步骤 2a 执行完之后，子进程结束</p>
<p>4) 父进程会捕捉子进程的退出信号，如果子进程的退出状态是 OK 的话，那么父进程将新输入命令的缓存追加到临时文件，然后使用 rename(2) 对临时文件改名，用它代替旧的 AOF 文件，至此，后台 AOF 重写完成。</p>
<p><strong>关于如何替代旧的AOF文件</strong></p>
<p><a href="https://github.com/huangz1990/redis-3.0-annotated/blob/unstable/src/aof.c" target="_blank" rel="noopener">todo</a></p>
<h5 id="优缺点分析-1"><a href="#优缺点分析-1" class="headerlink" title="优缺点分析"></a>优缺点分析</h5><p><strong>优点</strong></p>
<p>AOF 让 Redis 变得非常耐久。通过同步策略控制，可以尽可能地减少AOF丢失的命令数据。AOF的默认策略是每秒钟 Fsync 一次，在这种配置下，就算发生故障停机，也最多丢失一秒钟的数据</p>
<p><strong>缺点</strong></p>
<p>AOF 的文件体积通常要大于 RDB 文件的体积。根据所使用的 Fsync 策略，AOF 的速度可能会慢于 RDB</p>
<h4 id="两种持久化方式对比"><a href="#两种持久化方式对比" class="headerlink" title="两种持久化方式对比"></a>两种持久化方式对比</h4><ul>
<li><p>Redis 支持同时开启 RDB 和 AOF，系统重启后，Redis 会优先使用 AOF 来恢复数据，这样丢失的数据会最少。</p>
</li>
<li><p>AOF 将 Redis 执行的每一条命令都实时的追加到磁盘中，处理大量的写入会降低Redis的性能，如果能接受AOF带来的性能损失，可以选择AOF持久化</p>
</li>
<li><p>RDB是定时做备份，如果能够接受定时的时间间隔内的数据丢失，那么可以选择RDB持久</p>
</li>
<li><p>RDB文件是定时生成的，非常便于数据库备份，并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度快。（AOF文件需要重新执行一遍指令）</p>
</li>
</ul>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>在Redis中，从服务器对主服务器的更换可以分为以下两种情况：</p>
<ul>
<li><strong>初次复制</strong>：从服务器没有复制过当前的主服务器</li>
<li><strong>断线后重复制</strong>：处于命令传播阶段的主从服务器因为网络问题而中断复制，从服务器通过自动重连，重新连接上主服务器并继续复制。</li>
</ul>
<p>Redis新版的复制功能：PSYNC命令具有完整重同步和部分重同步两种模式：</p>
<ul>
<li><strong>完整重同步用于处理初次复制情况</strong>：他们是通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓冲区里面的写命令进行同步的</li>
<li><strong>部分重同步用于处理断线后的重复制情况</strong>：（PS：因为断线之后复制，只是为了弥补断线期间缺失的一小部分数据，实施完整重同步的做法是非常低效的）当从服务器断线后重新连接主服务器时，如果条件允许，主服务器可以将从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接受并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态</li>
</ul>
<h3 id="复制功能的原理"><a href="#复制功能的原理" class="headerlink" title="复制功能的原理"></a>复制功能的原理</h3><p>Redis的复制功能分为同步和命令传播两个操作</p>
<ul>
<li>同步操作用于将从服务器的数据库状态更新至主服务器当前所处的状态</li>
<li>而命令传播操作则用于在主服务器的数据库状态被修改， 导致主从服务器的数据库状态出现不一致时， 让主从服务器的数据库重新回到一致状态。</li>
</ul>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><h5 id="完整重同步"><a href="#完整重同步" class="headerlink" title="完整重同步"></a>完整重同步</h5><ol>
<li>从向主发送SYNC命令</li>
<li>主收到命令后执行BGSAVE，在后台生成RDB文件，并使用一个缓冲区记录从执行BGSAVE开始执行的所有写命令</li>
<li>当主的BGSAVE命令执行完毕时，主会将BGSAVE在后台生成的RDB文件发送给从服务器，从服务器接收并载入这个 RDB 文件， 将自己的数据库状态更新至主服务器执行 BGSAVE 命令时的数据库状态。</li>
<li>主服务器将记录在缓冲区里面的所有写命令发送给从服务器， 从服务器执行这些写命令， 将自己的数据库状态更新至主服务器数据库当前所处的状态。</li>
</ol>
<h5 id="部分重同步"><a href="#部分重同步" class="headerlink" title="部分重同步"></a>部分重同步</h5><p>部分重同步功能由以下三个部分构成：</p>
<ul>
<li>主服务器的<strong>复制偏移量</strong>（replication offset）和从服务器的复制偏移量</li>
<li><strong>主服务器的复制积压缓冲区（replication backlog）</strong></li>
<li><strong>服务器的运行ID</strong>（run ID）</li>
</ul>
<h6 id="复制偏移量"><a href="#复制偏移量" class="headerlink" title="复制偏移量"></a>复制偏移量</h6><p>执行复制的双方—主服务器和从服务器会分别维护一个复制偏移量：</p>
<ul>
<li>主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N</li>
<li>从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N</li>
</ul>
<p><strong>通过对比主从服务器的复制偏移量，程序可以很容易地知道主从服务器是否处于一致状态</strong>：</p>
<ul>
<li>如果主从服务器处于一致状态，那么主从服务器两者的偏移量总是相同的</li>
<li>相反，如果主从服务器两者的偏移量并不相同，那么说明主从服务器并未处于一致状态</li>
</ul>
<blockquote>
<p>从服务器A在断线之后就立即重新连接主服务器，并且成功，那么接下来，<strong>从服务器将向主服务器发送PSYNC命令</strong>，并报告自己的偏移量，<strong>主服务器将根据偏移量和复制积压缓冲区决定执行完整重同步还是部分重同步</strong></p>
</blockquote>
<h6 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h6><p>复制积压缓冲区是由主服务器维护的一个固定长度（fixed-size）先进先出（FIFO）队列，默认大小为1MB。</p>
<p><strong>当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区里面</strong>。因此，主服务器的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量</p>
<p>当从服务器重新连上主服务器时，从服务器会通过PSYNC命令将自己的复制偏移量offset发送给主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作：</p>
<ul>
<li>如果offset偏移量之后的数据（也即是偏移量offset+1开始的数据）仍然存在于复制积压缓冲区里面，那么主服务器将对从服务器执行部分重同步操作；</li>
<li>相反，如果offset偏移量之后的数据已经不存在于复制积压缓冲区，那么主服务器将对从服务器执行完整重同步操作。</li>
</ul>
<p><strong>关于缓冲区大小设置</strong></p>
<p>如果主服务器平均每秒产生1 MB的写数据，而从服务器断线之后平均要5秒才能重新连接上主服务器，那么复制积压缓冲区的大小就不能低于5MB。为了安全起见，可以将复制积压缓冲区的大小设为2*second*write_size_per_second，这样可以保证绝大部分断线情况都能用部分重同步来处理</p>
<h6 id="服务器运行ID"><a href="#服务器运行ID" class="headerlink" title="服务器运行ID"></a>服务器运行ID</h6><p>除了复制偏移量和复制积压缓冲区之外，实现部分重同步还需要用到服务器运行ID（run ID）:</p>
<ul>
<li>每个Redis服务器，<strong>不论主服务器还是从服务，都会有自己的运行ID</strong>；</li>
<li>运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成，例如53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b — <a href="https://juejin.im/post/5b3a23746fb9a024e15cad79#heading-11" target="_blank" rel="noopener">[分布式唯一ID生成的集中方案]</a></li>
</ul>
<p>当从服务器对主服务器进行初次复制时，主服务器会将自己的运行ID传送给从服务器，而从服务器则会将这个运行ID保存起来（注意哦，是<strong>从服务器保存了主服务器的ID</strong>），当从服务器断线并重新连上一个主服务器时，<strong>从服务器将向当前连接的主服务器发送之前保存的运行ID</strong>：</p>
<ul>
<li>如果从服务器保存的运行ID和当前连接的主服务器的运行ID相同，那么说明从服务器断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行部分重同步操作；</li>
<li>相反地，如果从服务器保存的运行ID和当前连接的主服务器的运行ID并不相同，那么说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服务器执行完整重同步操作。</li>
</ul>
<h4 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h4><p>在同步操作执行完毕之后， 主从服务器两者的数据库将达到一致状态， 但这种一致并不是一成不变的 —— <strong>每当主服务器执行客户端发送的写命令时， 主服务器的数据库就有可能会被修改， 并导致主从服务器状态不再一致</strong>。</p>
<p>为了让主从服务器再次回到一致状态， 主服务器需要对从服务器执行命令传播操作： 主服务器会将自己执行的写命令 —— 也即是造成主从服务器不一致的那条写命令 —— 发送给从服务器执行， 当从服务器执行了相同的写命令之后， 主从服务器将再次回到一致状态。</p>
<h3 id="复制功能的实现"><a href="#复制功能的实现" class="headerlink" title="复制功能的实现"></a>复制功能的实现</h3><p>有六个步骤：（1）设置主服务器的地址和端口；（2）建立套接字连接；（3）发送PING命令；（4）身份验证；（5）发送端口信息；（6）同步；（7）命令传播</p>
<p>下面将对这六个步骤展开讲述：</p>
<ol>
<li><p>步骤一：设置主服务器的地址和端口</p>
</li>
<li><p>步骤二：建立套接字连接</p>
</li>
<li><p>步骤三：发送PING命令</p>
<p>这个PING命令主要是为了：</p>
<ul>
<li>通过发送PING命令检查套接字的读写状态</li>
<li>通过PING命令可以检查主服务器能否正常处理命令</li>
</ul>
<p>从服务器在发送PING命令之后可能遇到以下三种情况：</p>
<ul>
<li>主服务器向从服务器返回了一个命令回复，但从服务器却不能在规定的时限内读取命令回复的内容(timeout)，说明网络连接状态不佳，从服务器将断开并重新创建连向主服务器的套接字</li>
<li>如果主服务器返回一个错误，那么表示主服务器暂时没有办法处理从服务器的命令请求，从服务器也将断开并重新创建连向主服务器的套接字</li>
<li>如果从服务器读取到”PONG”回复，那么表示主从服务器之间的网络连接状态正常，那就继续执行下面的复制步骤</li>
</ul>
</li>
<li><p>步骤四：身份验证</p>
</li>
</ol>
<p><img src="https://images0.cnblogs.com/blog2015/754165/201508/111612480989940.png" alt="img"></p>
<ol start="5">
<li><p>步骤五：发送端口信息</p>
<p>slave_listening_port属性目前唯一的作用就是在主服务器执行INFO replication命令时打印出从服务器的端口号（貌似暂时作用不大）</p>
</li>
<li><p>步骤六：同步</p>
<p>在这一步，从服务器将向主服务器发送PSYNC命令，执行同步操作，并将自己的数据库更新至主服务器数据库当前所处的状态</p>
<p>需要注意的是在执行同步操作前，<strong>只有从服务器是主服务器的客户端。但是执行从不操作之后，主服务器也会称为从服务器的客户端</strong>：</p>
<ul>
<li>如果PSYNC命令执行的是完整同步操作，那么主服务器只有成为了从服务器的客户端才能将保存在<strong>缓冲区中的写命令</strong>发送给从服务器执行</li>
<li>如果PSYNC命令执行的是部分同步操作，那么主服务器只有成为了从服务器的客户端才能将保存在<strong>复制积压缓冲区中的写命令</strong>发送给从服务器执行</li>
</ul>
</li>
<li><p>步骤七：命令传播</p>
<p>当完成了同步之后，主从服务器就会进入命令传播阶段，这时主服务器只要一直将自己执行的写命令发送给从服务器，而从服务器只要一直接收并执行主服务器发来的写命令，就可以保证主从服务器一直保持一致了</p>
</li>
</ol>
<h3 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h3><p>在命令传播阶段，从服务器默认会以<strong>每秒一次的频率</strong>，向主服务器发送命令：<strong>REPLCONF ACK <replication_offset></strong>，其中replication_offset是从服务器当前的复制偏移量</p>
<p>发送REPLCONF ACK命令对于主从服务器有三个作用：</p>
<ul>
<li>检测主从服务器的网络连接状态</li>
<li>辅助实现min-slaves选项</li>
<li><strong>检测命令丢失</strong></li>
</ul>
<h4 id="检测主从服务器的网络连接状态"><a href="#检测主从服务器的网络连接状态" class="headerlink" title="检测主从服务器的网络连接状态"></a>检测主从服务器的网络连接状态</h4><p><strong>如果主服务器超过一秒钟没有收到从服务器发来的REPLCONF ACK命令，那么主服务器就知道主从服务器之间的连接出现问题了</strong>。</p>
<p>通过向主服务器发送<strong>INFO replication命令</strong>，在列出的从服务器列表的lag一栏中，我们可以看到相应从服务器最后一次向主服务器发送REPLCONF ACK命令距离现在过了多少秒</p>
<h4 id="辅助实现min-slaves选项"><a href="#辅助实现min-slaves选项" class="headerlink" title="辅助实现min-slaves选项"></a>辅助实现min-slaves选项</h4><p>Redis的<strong>min-slaves-to-write</strong>和<strong>min-slaves-max-lag</strong>两个选项可以<strong>防止主服务器在不安全的情况下执行写命令。</strong></p>
<p>举个例子，如果我们向主服务器提供以下设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write 3</span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure>

<p>那么在<strong>从服务器的数量少于3个，或者三个从服务器的延迟（lag）值都大于或等于10秒时</strong>，主服务器将拒绝执行写命令，这里的延迟值就是上面提到的INFO replication命令的lag值</p>
<h4 id="检测命令丢失"><a href="#检测命令丢失" class="headerlink" title="检测命令丢失"></a>检测命令丢失</h4><p>我们从命令：REPLCONF ACK <replication_offset>就可以知道，每发送一次这个命令从服务器都会向主服务器报告一次自己的复制偏移量。如果因为网络故障，主服务器传播给从服务器的写命令在半路丢失，那么通过这个ACK可以检测是否由丢失</p>
<p>当主服务器发觉从服务器当前的复制偏移量少于自己的复制偏移量，<strong>然后主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区里面找到从服务器缺少的数据</strong>，并将这些数据重新发送给从服务器</p>
<p>Note：主服务器向从服务器补发缺失数据的原理和部分重同步的原理非常相似，它们的区别在于：补发缺失数据操作在主从服务器没有断线的情况下执行，而部分重同步操作则在主从服务器断线并重连之后执行。</p>
<h3 id="主从复制优缺点"><a href="#主从复制优缺点" class="headerlink" title="主从复制优缺点"></a>主从复制优缺点</h3><blockquote>
<p>想了解一样东西的时候，必须明白它的优缺点</p>
</blockquote>
<p><a href="https://juejin.im/post/5b7d226a6fb9a01a1e01ff64" target="_blank" rel="noopener">[Reference]</a></p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p><code>Redis</code> <strong>主从复制</strong> 可将 <strong>主节点</strong> 数据同步给 <strong>从节点</strong>，从节点此时有两个作用：</p>
<ol>
<li>一旦 <strong>主节点宕机</strong>，<strong>从节点</strong> 作为 <strong>主节点</strong> 的 <strong>备份</strong> 可以随时顶上来。</li>
<li>扩展 <strong>主节点</strong> 的 <strong>读能力</strong>，分担主节点读压力。</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p><strong>主从复制</strong> 同时存在以下几个问题：</p>
<ol>
<li>一旦 <strong>主节点宕机</strong>，<strong>从节点</strong> 晋升成 <strong>主节点</strong>，同时需要修改 <strong>应用方</strong> 的 <strong>主节点地址</strong>，还需要命令所有 <strong>从节点</strong> 去 <strong>复制</strong> 新的主节点，整个过程需要 <strong>人工干预</strong></li>
<li><strong>主节点</strong> 的 <strong>写能力</strong> 受到 <strong>单机的限制</strong></li>
<li><strong>主节点</strong> 的 <strong>存储能力</strong> 受到 <strong>单机的限制</strong></li>
<li><strong>原生复制</strong> 的弊端在早期的版本中也会比较突出，比如：<code>Redis</code> <strong>复制中断</strong> 后，<strong>从节点</strong> 会发起 <code>psync</code>。此时如果 <strong>同步不成功</strong>，则会进行 <strong>全量同步</strong>，<strong>主库</strong> 执行 <strong>全量备份</strong> 的同时，可能会造成毫秒或秒级的 <strong>卡顿</strong></li>
</ol>
<h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p><a href="https://juejin.im/post/5b7d226a6fb9a01a1e01ff64" target="_blank" rel="noopener">[值得仔细阅读]</a></p>
<h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><p>Redis Sentinel（哨兵）主要功能包括主节点存活检测、主从运行情况检测、自动故障转移、主从切换。Redis Sentinel 最小配置是一主一从</p>
<p>Redis 的 Sentinel 系统可以用来管理多个 Redis 服务器，该系统可以执行以下四个任务：</p>
<ol>
<li><p>监控</p>
<p>Sentinel会不断的检查主服务器和从服务器是否正常运行</p>
</li>
<li><p>通知</p>
<p>当被监控的某个 Redis 服务器出现问题，Sentinel 通过 API 脚本向管理员或者其他应用程序发出通知</p>
</li>
<li><p>自动故障转移</p>
<p>当 <strong>主节点</strong> 不能正常工作时，<code>Sentinel</code> 会开始一次 <strong>自动的</strong> 故障转移操作，它会将与 <strong>失效主节点</strong> 是 <strong>主从关系</strong> 的其中一个 <strong>从节点</strong> 升级为新的 <strong>主节点</strong>，并且将其他的 <strong>从节点</strong> 指向 <strong>新的主节点</strong></p>
</li>
<li><p>配置提供者</p>
<p>在 <code>Redis Sentinel</code> 模式下，<strong>客户端应用</strong> 在初始化时连接的是 <code>Sentinel</code> <strong>节点集合</strong>，从中获取 <strong>主节点</strong> 的信息。</p>
</li>
</ol>
<h3 id="工作原理-2"><a href="#工作原理-2" class="headerlink" title="工作原理"></a>工作原理</h3><h4 id="哨兵准备工作"><a href="#哨兵准备工作" class="headerlink" title="哨兵准备工作"></a>哨兵准备工作</h4><p>启动并初始化 Sentinel</p>
<p>获取主服务器信息</p>
<p>获取从服务器信息</p>
<p>向主服务器和从服务器发送信息</p>
<p>接收来自主服务器和从服务器的频道信息</p>
<h4 id="主要工作内容"><a href="#主要工作内容" class="headerlink" title="主要工作内容"></a>主要工作内容</h4><h5 id="检测主观下线状态"><a href="#检测主观下线状态" class="headerlink" title="检测主观下线状态"></a>检测主观下线状态</h5><p><strong>主观下线</strong> 适用于检测所有与它创建了命令连接的实例（包括主服务器、从服务器、其它Sentinel在内）。如果在 <code>down-after-milliseconds</code> 毫秒内，<code>Sentinel</code> 没有收到 <strong>目标节点</strong> 的有效回复，则会判定 <strong>该节点</strong> 为 <strong>主观下线</strong></p>
<p>在默认情况下，每个Sentinel以每秒钟一次的频率向所有与它创建了命令连接的实例（包括主服务器、从服务器、其它Sentinel在内）发送一个PING命令，并通过实例返回的PING命令回复来判断实例是否在线</p>
<h5 id="检查客观下线状态"><a href="#检查客观下线状态" class="headerlink" title="检查客观下线状态"></a>检查客观下线状态</h5><p>当Sentinel将一个主服务器判断为主管下线之后，为了确认这个主服务器是否真的下线了，它会向同样监视这个服务器的其他Sentinel进行询问，看他们是否也认为该主服务器进入下线状态。<strong>当从其他Sentinel那里接收到足够数量已下线判断后，sentinel会将该主服务器判定为客观下线状态</strong></p>
<h5 id="选举领头-Sentinel"><a href="#选举领头-Sentinel" class="headerlink" title="选举领头 Sentinel"></a>选举领头 Sentinel</h5><p> Sentinel系统选举领头Sentinel的方法是对Raft算法的领头选举方法的实现</p>
<h5 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h5><p>在选举产生出领头Sentinel之后，领头Sentinel将对已下线的主服务器执行故障转移操作，该操作包含三个步骤：</p>
<ol>
<li>在已下线主服务器属下的所有从服务器里面，挑选出一个从服务器，并将其转换为主服务器 （挑选的规则可以看下）</li>
<li>让已下线主服务器属下的所有从服务器改为复制新的主服务器</li>
<li>已下线主服务器设置为新的主服务器的从服务器</li>
</ol>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>Redis集群是Redis提供的分布式数据库方案，集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能</p>
<p>集群功能的实现主要由集群的节点、槽指派、命令执行、重新分片、转向、故障转移、消息等几个方面组成</p>
<h3 id="集群节点"><a href="#集群节点" class="headerlink" title="集群节点"></a>集群节点</h3><p>一个Redis集群通常由多个节点（node）组成，在刚开始的时候，每个节点都是相互独立的，它们都处于一个只包含自己的集群当中，要组建一个真正可工作的集群，我们必须将各个独立的节点连接起来，构成一个包含多个节点的集群</p>
<p>下图展示了节点握手过程，客户端通过向节点A发送CLUSTER MEET命令，<strong>可以让接收命令的节点A将另一个节点B添加到节点A当前所在的集群里面</strong>（这也就是握手过程）</p>
<p><img src="http://redisbook.com/_images/graphviz-76550f578052d5f52e35414facb5ac680d38c7f5.png" alt="Redisbook"></p>
<p>握手完成之后，节点A会将节点B的信息通过<strong>Gossip协议</strong>传播给集群中的其它节点，让其它节点也与节点B进行握手。最终，经过一段时间之后，节点B会被集群中的所有节点认识</p>
<h3 id="槽指派"><a href="#槽指派" class="headerlink" title="槽指派"></a>槽指派</h3><p><strong>Redis集群没有使用一致性hash,而是引入了哈希槽的概念</strong>，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算给定键key属于哪个槽</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">slot_number</span><span class="params">(key)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> CRC16(key) &amp; <span class="number">16383</span></span><br></pre></td></tr></table></figure>

<p><strong>Redis集群通过分片的方式来保存数据库的键值对</strong>：集群中的整个数据库被分为16384个槽（slot），数据库中的每个键都属于其中的一个，集群中的每个节点可以处理0个或最多16384个槽</p>
<p>当数据库中的16384个槽都有节点在处理时，集群处于上线状态（ok），<strong>如果任何一个槽都没有得到处理</strong>，就处于下线状态（fail）</p>
<p><strong>下面的内容主要介绍了保存槽指派信息的方法，以及节点之间传播槽指派信息的方法</strong></p>
<ol>
<li><p>记录节点的槽指派信息</p>
<p>通过索引i上的二进制位的值来判断节点是否负责处理槽i，所以取出和设置slots数组中的任意一个二进制位的值的复杂度仅为O(1)</p>
</li>
<li><p>传播节点的槽指派信息</p>
<p>一个节点除了会将自己负责处理的槽记录在<strong>clusterNode</strong>结构的slots属性和numslots属性之外，它还会将自己的slots数组通过消息发送给集群中的其他节点，来告知其他节点自己目前负责处理哪些槽。</p>
<p>因为集群中的每个节点都会将自己的slots数组通过消息发送给集群中的其他节点，并且每个接收到slots数组的节点都会将数组保存到相应节点的clusterNode结构里面，因此，集群中的每个节点都会知道数据库中的16384个槽分别被指派给了集群中的哪些节点。</p>
</li>
<li><p>记录集群所有槽的指派信息</p>
<p><strong>clusterState结构中也有一个slots数组，该数组记录了集群中所有16384个槽的指派信息，每个数组项都是一个指向clusterNode结构的指针.</strong> 注意clusterState是每一个节点都有的，且集群中的每个节点的clusterState中的slots数组都想同，从而使得节点能够互相知道哪个槽指派给了哪个节点</p>
<p>cluterNode针对自己，clusterState针对集群</p>
<ul>
<li>clusterState.slots数组记录了集群中所有槽的指派信息</li>
<li>clusterNode.slots数组只记录了clusterNode结构所代表的节点的槽指派信息，clusterNode.slots只能明白自己是否与负责某个槽</li>
<li>1 当为了检索槽i是否已经被指派，或者槽i被指派给了哪个节点，程序有两种方案：第一，遍历nodes字典，检查所有的clusterNode.slots，这个时间复杂度是O(N)，其中N为clusterNode的数量；第二，如果有clusterState.slots存在，则只需要通过索引i访问即可，这个操作时间复杂度是O(1)，显然clusterState<strong>有存在的必要</strong></li>
<li>clusterNode.slots存在的必要在于当程序需要将某个节点的槽指派信息发送给其他节点时可以直接使用clusterNode.slots数组信息</li>
</ul>
</li>
</ol>
<p>通过<code>CLUSTER ADDSLOTS</code>命令的将所有输入的槽指派给接收该命令的节点负责，最后在<code>CLUSTER ADDSLOTS</code>命令执行完毕之后，节点会通过发送消息告知集群中的其它节点，自己目前正在处理哪些槽</p>
<h3 id="集群中命令执行"><a href="#集群中命令执行" class="headerlink" title="集群中命令执行"></a>集群中命令执行</h3><h4 id="命令执行流程"><a href="#命令执行流程" class="headerlink" title="命令执行流程"></a>命令执行流程</h4><p>指派完所有的槽以后，集群会进入上线状态，此时客户端可以向集群中的节点发送数据命令</p>
<p>当客户端向节点发送与数据库键有关的命令时，<strong>接收命令的节点会计算出命令要处理的数据库键属于哪个槽，并检查这个槽是否指派给了自己：</strong></p>
<ul>
<li>如果指派给自己，执行</li>
<li>否则，返回MOVED错误，并<strong>将客户端指向正确的节点</strong></li>
</ul>
<h4 id="MOVED错误"><a href="#MOVED错误" class="headerlink" title="MOVED错误"></a>MOVED错误</h4><p>当节点发现键所在的槽并非由自己负责处理的时候，节点就会向客户端返回一个MOVED错误，指引客户端转向至正在负责槽的节点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MOVED错误的格式</span></span><br><span class="line">MOVED &lt;slot&gt; &lt;ip&gt;:&lt;port&gt;</span><br></pre></td></tr></table></figure>

<p><strong>MOVED简单实现原理</strong>：一个集群客户端通常会与集群中的多个节点创建套接字连接，而所谓的节点转向实际上就是换一个套接字发送命令（如果客户端尚未与想要转向的节点创建套接字连接，那么客户端会先根据MOVED错误提供的IP地址和端口号来连接节点，然后再进行转向）</p>
<h4 id="节点数据库实现"><a href="#节点数据库实现" class="headerlink" title="节点数据库实现"></a>节点数据库实现</h4><p>集群节点<strong>保存键值对</strong>以及<strong>键值对过期时间</strong>的方式，与单机Redis服务器完全相同</p>
<p>节点和单机服务器在数据库方面的一个区别是，节点只能使用0号数据库，而单机Redis服务器则没有这一限制</p>
<p>除了将键值对保存在数据库里面之外，节点还会有clusterState结构中的slots_to_keys跳跃表来保存槽和键之间的关系。slots_to_keys跳跃表每个节点的分值（score）都是一个槽号，而每个节点的成员（member）都是一个数据库键，通过在slots_to_keys跳跃表中记录各个数据库键所属的槽，节点可以很方便的对属于某个或某些槽的所有数据库键进行批量操作  </p>
<h3 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>Redis集群的重新分片操作可以将<strong>任意数量已经指派给某个节点（源节点）的槽改为指派给另一个节点（目标节点）</strong>，并且相关槽所属的键值对也会从源节点被移动到目标节点</p>
<p>重新分片操作可以<strong>在线（online）进行</strong>，在重新分片的过程中，集群不需要下线，并且<strong>源节点和目标节点都可以继续处理命令请求</strong></p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>Redis集群的重新分片操作是由Redis的集群管理软件<strong>redis-trib</strong>负责执行的，<strong>Redis提供了进行重新分片所需的所有命令</strong>，而redis-trib则<strong>通过向源节点和目标节点发送命令来进行重新分片操作</strong></p>
<p>重新分配步骤如下：</p>
<p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200112105535.png" alt="img"></p>
<p>如果重新分片涉及多个槽，那么redis-trib将对每个给定的槽分别执行上面给出的步骤。</p>
<p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200112105711.png" alt="img"></p>
<h4 id="重新分片中的转向"><a href="#重新分片中的转向" class="headerlink" title="重新分片中的转向"></a>重新分片中的转向</h4><h5 id="ASK错误"><a href="#ASK错误" class="headerlink" title="ASK错误"></a>ASK错误</h5><p><strong>正在重新分片时</strong>，属于被迁移槽的一部分键值对保存在源节点里面，而另一部分键值对则保存在目标节点里面</p>
<p>当客户端向源节点发送一个与数据库键有关的命令，并且命令要处理的数据库键恰好就属于正在被迁移的槽时：</p>
<ul>
<li>槽在自己这里，执行客户端命令</li>
<li>槽不在，返回ASK错误，指引客户端转向正在导入槽的目标节点</li>
</ul>
<p>ASK错误实现原理</p>
<ol>
<li><code>clusterState</code>结构的<code>importing_slots_from</code>数组记录了当前节点正在从其他节点导入的槽</li>
<li><code>clusterState</code>结构的<code>migrating_slots_to</code>数组记录了当前节点正在迁移至其他节点的槽</li>
<li>通过<code>migrating_slots_to</code>这个数组，我们知道当前节点的某个键是否正在迁移。如果是则返回ASK错误</li>
</ol>
<p><img src="https://xiaoyue26.github.io/images/2019-03/ask_query.png" alt="img"></p>
<p>ASKING命令的目的就是打开REDIS_ASKING标识，而且<strong>是一次性的打开</strong>，意味着使用完后会被关闭。</p>
<p>当客户端收到ASK错误并转向正在导入槽的节点时，客户端会先向节点发送一个ASKING命令，然后才重新发送想要执行的命令，这是因为如果客户端不发送ASKING命令，而直接发送想要执行的命令的话，那么客户端发送的命令会被节点拒绝执行，并返回MOVED错误</p>
<h3 id="转向"><a href="#转向" class="headerlink" title="转向"></a>转向</h3><p>ASK错误和MOVED错误都会导致客户端转向，它们的区别在于：</p>
<ul>
<li>MOVED错误代表槽的负责权已经从一个节点转移到了另一个节点：在客户端收到关于槽i的MOVED错误之后，客户端每次遇到关于槽i的命令请求时，都可以直接将命令请求发送至MOVED错误所指向的节点，因为该节点就是目前负责槽i的节点</li>
<li>与此相反，ASK错误只是两个节点在迁移槽的过程中使用的一种临时措施：在客户端收到关于槽i的ASK错误之后，客户端只会在接下来的一次命令请求中将关于槽i的命令请求发送至ASK错误所指示的节点，但这种转向不会对客户端今后发送关于槽i的命令产生任何影响，客户端仍然会将关于槽i的命令请求发送至目前负责处理槽i的节点，除非ASK错误再次出现</li>
</ul>
<h3 id="故障转移-1"><a href="#故障转移-1" class="headerlink" title="故障转移"></a>故障转移</h3><p>Redis集群中的节点分为主节点和从节点，其中主节点用于处理槽，而从节点则用于复制某个主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求</p>
<p><strong>故障转移的整体思路与哨兵模式类似，主要是节点复制、检测节点是否下线以及对下线主节点进行故障</strong></p>
<ol>
<li><p>设置从节点 — 接收到命令的从节点开始对主节点进行复制</p>
</li>
<li><p>故障检测  </p>
<ol>
<li><strong>集群中的每个节点都会定期地向集群中的其它节点发送PING消息，以此来检测对方是否在线，如果接收PING消息的节点没有在规定的时间内，向发送PING消息的节点返回PONG消息，那么发送PING消息的节点就会将接收PING消息的节点标记为疑似下线</strong></li>
<li>如果在一个集群里面，半数以上负责处理槽的主节点都会将某个主节点x报告为疑似下线，那么这个主节点x将被标记为已下线，将主节点x标记为已下线的节点会向集群广播一条关于主节点x已下线的消息，所有收到这条消息的节点都立即将主节点x标记为已下线</li>
</ol>
</li>
<li><p>故障转移</p>
<p>选出新的主节点-&gt;槽指派-&gt;集群广播</p>
<p>当一个从节点发现自己正在复制的主节点进入了已下线状态时，从节点将开始对下线主节点进行故障转移，以下是故障转移的执行步骤：</p>
<ol>
<li>从已下线主节点中选出一个从节点</li>
<li>从节点执行SLAVEOF no one命令，成为新的主节点</li>
<li>新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己</li>
<li>新的主节点向集群广播一条PONG消息，这条PONG消息可以让集群中的其他节点立即知道这个节点已经由从节点变成了主节点。</li>
<li>新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成</li>
</ol>
</li>
</ol>
<h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p><strong>集群中的各个节点通过发送和接收消息（message）来进行通信</strong>，节点发送的消息主要有以下五种：</p>
<ul>
<li><strong>MEET消息：</strong>当发送者接到客户端发送的CLUSTER MEET命令时，发送者会<strong>向接收者</strong>发送MEET消息，请求接收者加入到发送者当前所处的集群里面</li>
<li><strong>PING消息：</strong>集群里的每个节点默认每隔一秒钟就会从<strong>已知节点列表中随机选出五个节点</strong>，然后对这五个节点中最长时间没有发送过PING消息的节点发送PING消息，以此来检测被选中的节点是否在线</li>
<li><strong>PONG消息：</strong>当接收者收到发送者发来的MEET消息或者PING消息时，为了向发送者确认这条MEET消息或者PING消息已到达，接收者<strong>会向发送者</strong>返回一条PONG消息。另外，一个节点也可以通过向<strong>集群广播</strong>自己的PONG消息来让集群中的其他节点立即刷新关于这个节点的认识</li>
<li><strong>FAIL消息：</strong>当一个主节点A判断另一个主节点B已经进入FAIL状态时，节点A会<strong>向集群广播</strong>一条关于节点B的FAIL消息，所有收到这条消息的节点都会立即将节点B标记为已下线</li>
<li><strong>PUBLISH消息</strong>：当节点接收到一个PUBLISH命令时，节点会执行这个命令，并<strong>向集群广播</strong>一条PUBLISH消息，所有接收到这条PUBLISH消息的节点都会执行相同的PUBLISH命令</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] 黄健宏. Redis设计与实现[M]. 机械工业出版社, 2014.</p>
<p>[2] <a href="https://juejin.im/post/5d776dcef265da03b574744d" target="_blank" rel="noopener">https://juejin.im/post/5d776dcef265da03b574744d</a></p>
<p>[3] <a href="https://juejin.im/post/5b7d226a6fb9a01a1e01ff64" target="_blank" rel="noopener">https://juejin.im/post/5b7d226a6fb9a01a1e01ff64</a></p>
<p>[4] <a href="https://zhuanlan.zhihu.com/p/86995658" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/86995658</a></p>
<p>[5] <a href="https://blog.csdn.net/zlfprogram/java/article/details/77715714" target="_blank" rel="noopener">https://blog.csdn.net/zlfprogram/java/article/details/77715714</a></p>
<p>[6] Redis博客 <a href="https://jiangren.work/tags/Redis/" target="_blank" rel="noopener">https://jiangren.work/tags/Redis/</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"># 读书笔记</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/02/25/Debug%E7%A5%9E%E5%99%A8Valgrind/" rel="prev" title="调试神器Valgrind">
      <i class="fa fa-chevron-left"></i> 调试神器Valgrind
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/03/23/StringSSO/" rel="next" title="string的短字符优化">
      string的短字符优化 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#浅析Redis"><span class="nav-number">1.</span> <span class="nav-text">浅析Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#What-is-Redis"><span class="nav-number">1.1.</span> <span class="nav-text">What is Redis?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis的特点"><span class="nav-number">1.1.1.</span> <span class="nav-text">Redis的特点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#优势"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">优势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#劣势"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">劣势</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis为什么这么快"><span class="nav-number">1.1.2.</span> <span class="nav-text">Redis为什么这么快</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis高可用-3"><span class="nav-number">1.1.3.</span> <span class="nav-text">Redis高可用[3]</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据结构与对象"><span class="nav-number">1.2.</span> <span class="nav-text">数据结构与对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件"><span class="nav-number">1.3.</span> <span class="nav-text">事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库操作"><span class="nav-number">1.4.</span> <span class="nav-text">数据库操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#过期策略"><span class="nav-number">1.4.0.1.</span> <span class="nav-text">过期策略</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存淘汰策略"><span class="nav-number">1.4.1.</span> <span class="nav-text">缓存淘汰策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#持久化方案及基本原理"><span class="nav-number">1.5.</span> <span class="nav-text">持久化方案及基本原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RDB"><span class="nav-number">1.5.0.1.</span> <span class="nav-text">RDB</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#工作原理"><span class="nav-number">1.5.0.1.1.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#优缺点分析"><span class="nav-number">1.5.0.1.2.</span> <span class="nav-text">优缺点分析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AOF"><span class="nav-number">1.5.0.2.</span> <span class="nav-text">AOF</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#工作原理-1"><span class="nav-number">1.5.0.2.1.</span> <span class="nav-text">工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#命令追加"><span class="nav-number">1.5.0.2.1.1.</span> <span class="nav-text">命令追加</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#文件写入与同步"><span class="nav-number">1.5.0.2.1.2.</span> <span class="nav-text">文件写入与同步</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#AOF文件重写"><span class="nav-number">1.5.0.2.1.3.</span> <span class="nav-text">AOF文件重写</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#AOF后台重写"><span class="nav-number">1.5.0.2.1.4.</span> <span class="nav-text">AOF后台重写</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#优缺点分析-1"><span class="nav-number">1.5.0.2.2.</span> <span class="nav-text">优缺点分析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#两种持久化方式对比"><span class="nav-number">1.5.0.3.</span> <span class="nav-text">两种持久化方式对比</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#主从复制"><span class="nav-number">1.6.</span> <span class="nav-text">主从复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#复制功能的原理"><span class="nav-number">1.6.1.</span> <span class="nav-text">复制功能的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#同步"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">同步</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#完整重同步"><span class="nav-number">1.6.1.1.1.</span> <span class="nav-text">完整重同步</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#部分重同步"><span class="nav-number">1.6.1.1.2.</span> <span class="nav-text">部分重同步</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#复制偏移量"><span class="nav-number">1.6.1.1.2.1.</span> <span class="nav-text">复制偏移量</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#复制积压缓冲区"><span class="nav-number">1.6.1.1.2.2.</span> <span class="nav-text">复制积压缓冲区</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#服务器运行ID"><span class="nav-number">1.6.1.1.2.3.</span> <span class="nav-text">服务器运行ID</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#命令传播"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">命令传播</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复制功能的实现"><span class="nav-number">1.6.2.</span> <span class="nav-text">复制功能的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#心跳检测"><span class="nav-number">1.6.3.</span> <span class="nav-text">心跳检测</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#检测主从服务器的网络连接状态"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">检测主从服务器的网络连接状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#辅助实现min-slaves选项"><span class="nav-number">1.6.3.2.</span> <span class="nav-text">辅助实现min-slaves选项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#检测命令丢失"><span class="nav-number">1.6.3.3.</span> <span class="nav-text">检测命令丢失</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主从复制优缺点"><span class="nav-number">1.6.4.</span> <span class="nav-text">主从复制优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#优点"><span class="nav-number">1.6.4.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺点"><span class="nav-number">1.6.4.2.</span> <span class="nav-text">缺点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哨兵模式"><span class="nav-number">1.7.</span> <span class="nav-text">哨兵模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#主要功能"><span class="nav-number">1.7.1.</span> <span class="nav-text">主要功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#工作原理-2"><span class="nav-number">1.7.2.</span> <span class="nav-text">工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#哨兵准备工作"><span class="nav-number">1.7.2.1.</span> <span class="nav-text">哨兵准备工作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主要工作内容"><span class="nav-number">1.7.2.2.</span> <span class="nav-text">主要工作内容</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#检测主观下线状态"><span class="nav-number">1.7.2.2.1.</span> <span class="nav-text">检测主观下线状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#检查客观下线状态"><span class="nav-number">1.7.2.2.2.</span> <span class="nav-text">检查客观下线状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#选举领头-Sentinel"><span class="nav-number">1.7.2.2.3.</span> <span class="nav-text">选举领头 Sentinel</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#故障转移"><span class="nav-number">1.7.2.2.4.</span> <span class="nav-text">故障转移</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集群"><span class="nav-number">1.8.</span> <span class="nav-text">集群</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#集群节点"><span class="nav-number">1.8.1.</span> <span class="nav-text">集群节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#槽指派"><span class="nav-number">1.8.2.</span> <span class="nav-text">槽指派</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集群中命令执行"><span class="nav-number">1.8.3.</span> <span class="nav-text">集群中命令执行</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令执行流程"><span class="nav-number">1.8.3.1.</span> <span class="nav-text">命令执行流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MOVED错误"><span class="nav-number">1.8.3.2.</span> <span class="nav-text">MOVED错误</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#节点数据库实现"><span class="nav-number">1.8.3.3.</span> <span class="nav-text">节点数据库实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重新分片"><span class="nav-number">1.8.4.</span> <span class="nav-text">重新分片</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#作用"><span class="nav-number">1.8.4.1.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原理"><span class="nav-number">1.8.4.2.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重新分片中的转向"><span class="nav-number">1.8.4.3.</span> <span class="nav-text">重新分片中的转向</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ASK错误"><span class="nav-number">1.8.4.3.1.</span> <span class="nav-text">ASK错误</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#转向"><span class="nav-number">1.8.5.</span> <span class="nav-text">转向</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#故障转移-1"><span class="nav-number">1.8.6.</span> <span class="nav-text">故障转移</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息"><span class="nav-number">1.8.7.</span> <span class="nav-text">消息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reference"><span class="nav-number">1.9.</span> <span class="nav-text">Reference</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">George</p>
  <div class="site-description" itemprop="description">It's gonna to be really fun!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">George</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
